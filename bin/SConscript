"""
Build FVS executable and shared libraries for a specific variant.  Called from
the SConstruct control script.

Author: Tod Haren, tod.haren@gmail.com
Date: 10/2013
"""

import os
import sys
import subprocess
import tempfile

#### ********************** README *******************************************
#### SCONS Platform.__init__.py modification near @line 203
#### Needed to properly escape the paths passed to the linker on windows
# prefix = env.subst('$TEMPFILEPREFIX')
# if not prefix:
#     prefix = '@'
#
# args = list(map(SCons.Subst.quote_spaces, cmd[1:]))
# + ##TODO: Test for MinGW or something else more sensible than GCC
# + #GCC expects command argument files to have special characters escaped
# + if env['CC'] == 'gcc':
# +     args = [arg.replace('\\','\\\\') for arg in args]
#
# os.write(fd, " ".join(args) + "\n")
# os.close(fd)
#### *************************************************************************

# #TODO: scons command line arguments arg=value are available in the ARGUMENTS
#        dictionary (eg. val = ARGUMENTS.get('foo',0))
# #TODO: GFortran linked exe's can not pass command line args to the dll.
#       Need to capture them in a seperate global variable of some sort.
#       Exists at GCC ver. 4.5, not tested at version 4.7

Import('*')
env = env.Clone()

# add the build directory (current when sconscript is called) to the compiler search paths
env['BUILD_DIR'] = Dir('.').abspath
env.Append(CPPPATH=env['BUILD_DIR'])
env.Append(FORTRANPATH=env['BUILD_DIR'])
env.Append(LIBPATH=env['BUILD_DIR'])

fvs_variant = 'fvs%s' % variant
env['F2PY_MODULE_NAME'] = fvs_variant

if not 'TEMP' in os.environ.keys():
    os.environ['TEMP'] = tempfile.gettempdir()
    os.environ['TMP'] = tempfile.gettempdir()
else:
    os.environ['TMP'] = os.environ['TEMP']

#ODBC is platform specific
if env['PLATFORM'] == 'win32':
    odbc = 'odbc32'
elif env['PLATFORM'] == 'posix':
    odbc = 'odbc'
else:
    raise Error('Platform not recognized %s' % env['PLATFORM'])

#
include_dirs = []
f2py_modules = []
main_sources = []
fvslib_sources = []
typedefs_sources = []
sqllib_sources = []
ffelib_sources = []
pyext_wrap_sources = []

def fix_paths(target, source, env):
    target = target.replace('\\', '/')
    source = source.replace('\\', '/')

#Process the source list file seperating them into components.
source_list = File(source_variants[variant]).srcnode().abspath
for source in open(source_list):
    ##NOTE: some compiler tools might assume some default behaviours based on
    #       file extension case, eg. .F77 != .f77, but lets ingnore that for now
    source = source.strip()
    source = source.replace('\\', '/')

    #repoint the source path to the build specific source tree
    source = os.path.join(env['SOURCE_ROOT'], source.replace('../', ''))

#    if not os.path.exists(source):
#        raise IOError('Source file not found: %s' % source)

    if source[0] == '#': continue

    f_path, f_name = os.path.split(source)
    f_basename, f_ext = os.path.splitext(f_name)

    ##TODO: move this to a seperate configuration
    if f_basename.lower() in (
            'fvs', 'apisubs', 'cmdline', 'filopn'
            ):
        pyext_wrap_sources.append(source)

    #include file, we just need their directory
    if f_ext.lower() in ('.f77', '.h', '.inc'):
        include_dirs.append(f_path)

    #main.f is only needed for the executable
    elif f_name.lower() in ('main.f',):
        main_sources.append(source)

    #FVS sources will be linked into the library
    elif f_ext.lower() in ('.f', '.f90'):
        fvslib_sources.append(source)

    elif f_name.lower() in ('mkdbstypedefs.c',):
        typedefs_sources.append(source)

    elif f_name.lower() in ('fvssql.c',):
        sqllib_sources.append(source)

    #remaining .c files are assumed to be FFE sources
    elif f_ext.lower() in ('.c',):
        ffelib_sources.append(source)

    #warn of any unhandled source files
    else:
        print('Unrecognized source file: %s; %s; %s; %s' % (f_path, f_name, f_basename, f_ext))
        raise

#Add the dirs found with include files to the compiler search paths
env.AppendUnique(CPPPATH=include_dirs)
env.AppendUnique(FORTRANPATH=include_dirs)

#Add the build folder to the search path
env.Append(FORTRANFLAGS='-J%s' % env['BUILD_DIR'])

if env['PLATFORM'] == 'win32':
    #force the tempfile munge routine to handle long command lines via tempfiles
    ##NOTE: If on Windows and Mingw GCC this fails, ensure the paths in the tempfile are escaped
    ##          eg. c:\path\to\foo.f -> c:\\path\\to\\foo.f
    env['LINKCOM'] = "${TEMPFILE(r'$LINK -o $TARGET $LINKFLAGS $__RPATH $SOURCES $_LIBDIRFLAGS $_LIBFLAGS')}"
    env['SHLINKCOM'] = "${TEMPFILE(r'$SHLINK $SHLINKFLAGS -o $TARGET $SOURCES $_LIBDIRFLAGS $_LIBFLAGS')}"

####Build the SQL typedefs include file
mkdbstypedefs_exe = env.Program(
        target='mkdbstypedefs'
        , source=typedefs_sources
        )
mkdbstypedefs_build = env.Command(
        target=os.path.join(env['BUILD_DIR'], "DBSTYPEDEFS.F77")
        , source=mkdbstypedefs_exe
        , action='${SOURCE.abspath}'
        , chdir=env['BUILD_DIR']
        )
env.Requires(mkdbstypedefs_build, mkdbstypedefs_exe)

####Compile all the FVS sources to an object list
##TODO: can this be a regular archive library, or is there any benefit
fvsobjs = env.SharedObject(
        fvslib_sources
        )

#keep only the *.o/*.os files, dropping the *.mod files
##TODO: add other compiler object file extensions
fvsobjs = [obj for obj in fvsobjs if obj.get_suffix() in ('.o', '.os')]

link_libs = []

#### Build the FVS SQL Library
sqlobjs = env.SharedObject(sqllib_sources)
if env['SHARED_SQL']:
    sqllib_name = 'FVSsql'
    sqllib = env.SharedLibrary(
            target=sqllib_name
            , source=sqlobjs
            , LIBS=[odbc, ]
            )
    #ensure DBSTYPEDEFS.F77 is fresh
    env.Depends(sqllib, mkdbstypedefs_build)
    link_libs.append(sqllib)

    env.Install(env['INSTALL_DIR'], sqllib)

else:
    sqllib = None
    link_libs.append(odbc)
    fvsobjs += sqlobjs

####Build the Fire extension lib
ffeobjs = env.SharedObject(ffelib_sources)
if env['SHARED_FIRE']:
    ffelib_name = 'FVSfofem'
    ffelib = env.SharedLibrary(
            target=ffelib_name
            , source=ffeobjs
            )
    env.Depends(ffelib, sqllib)
    link_libs.append(ffelib)

    env.Install(env['INSTALL_DIR'], ffelib)

else:
    ffelib = None
    fvsobjs += ffeobjs

####Link the FVS Shared Library
fvslib = env.SharedLibrary(
        target='FVS_%s' % variant.lower()
        , source=fvsobjs
        , LIBS=link_libs
        , LIBPATH=[env['BUILD_DIR'], ]
        )

env.Install(env['INSTALL_DIR'], fvslib)
#env['FVSLIB'] = fvslib

if env['SHARED_FIRE']:
    env.Depends(fvslib, ffelib)

if env['SHARED_SQL']:
    env.Depends(fvslib, sqllib)
else:
    env.Depends(fvslib, mkdbstypedefs_build)

####Link the FVS Executable
if env['WITH_EXE']:
    if not env['STATIC_EXE']:
        fvsexe = env.Program(
                target='FVS%s' % variant.lower()
                , source=main_sources
                , LIBS=[fvslib, ])
        env.Depends(fvsexe, fvslib)

    else:
        #static link FVS lib with exe
        #GFortran shared libraries (DLL) do not currently have access to the command line arguments
        link_libs = []
        sources = list(set(main_sources + fvsobjs))

        if env['SHARED_FIRE']:
            link_libs.append(ffelib_name)
        else:
            sources += ffeobjs

        if env['SHARED_SQL']:
            link_libs.append(sqllib_name)
        else:
            link_libs.append(odbc)
            sources += sqlobjs

        fvsexe = env.Program(target=fvs_variant, source=sources, LIBS=link_libs)

        if env['SHARED_FIRE']:
            env.Depends(fvsexe, ffelib)

        if env['SHARED_SQL']:
            env.Depends(fvsexe, sqllib)

    env.Install(env['INSTALL_DIR'], fvsexe)

#call the Python extension builders
if env['WITH_PYEXT']:
    pymodname = 'pyfvs%s' % variant.lower()
    print('Build the Python extension for variant %s' % variant.lower())
    pyext_wrapper = env.F2PYWrapper(pymodname, pyext_wrap_sources)

    if env['STATIC_PYEXT']:
        #statically link the Python extension
        pyext_lib = env.F2PYLibrary(pymodname, pyext_wrapper
                , link_objs=fvsobjs, link_libs=link_libs)
        env.Depends(pyext_wrapper, fvsobjs)

    else:
        #link to the fvs shared library
        pyext_lib = env.F2PYLibrary(pymodname, pyext_wrapper
                , link_objs=[], link_libs=[fvslib, ])
        env.Depends(pyext_wrapper, fvslib)

    env.Depends(pyext_lib, pyext_wrapper)
    env.Install(env['INSTALL_DIR'], pyext_lib)

env.Alias('install', env['INSTALL_DIR'])
Decider('MD5-timestamp')
