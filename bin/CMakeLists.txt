# This CMakeLists file will generate a hierarchical build for Open-FVS.
#
# Note that every effort has been made to be platform independent, but surely
# some things will be overlooked. Please let us know of any bugs or quirks.
# Some support is included for Visual Studio and Intel compilers, but most 
# work supports GCC/GFortran under MinGW and Linux.
#
# Alternate configurations can be generated by calling cmake from configuration
# specific folders.  This may be useful for keeping a test/debug environment
# and release build in the same folder tree. Cmake tracks all dependent source 
# files and generated object code within the project subfolder, thus avoiding 
# cross-build polution and redundant compilation where possible.
#
# Generated binaries are placed in the FVSbin subfolder.
#
# Example: A project folder for a debug build and a seperate folder for releas
#   mkdir <FVS bin>/debug
#   cd <FVS bin>/debug
#   cmake -G"MinGW Makefiles" -DFVS_VARIANTS=pnc;wcc -DCMAKE_BUILD_TYPE=DEBUG
#   mingw32-make -j2
#
#   mkdir <FVS bin>/release
#   cd <FVS bin>/release
#   cmake -G"MinGW Makefiles" -DFVS_VARIANTS=pnc;wcc -DCMAKE_BUILD_TYPE=RELEASE
#   mingw32-make -j2
#
# CMake will create a subfolder for each FVS variant, copy in the cmake list 
# and source list files.  A sub-project is then specified for each variant. The
# common libraries (FVSsql,FVSfofem) are built in the top evel folder where 
# they can be located by each variant sub-project.
#
# The result is a target for each executable, library, Python module. These
# targets can then be built individually or as a group with the "all" target. 
# For instance "mingw32-make FVSpnc" would generate the common libraries, the
# PNC shared library and the PNC executable.  "mingw32-make pyfvspnc" would 
# result in the common libraries, PNC shared library, and the Python module
# module, but not the PNC executable.  "mingw32-make FVS_pnc" would result in 
# common libraries and the PNC shared library, but no executable or Python
# module.  Any combination of targets can be specified in one call to
# "mingw32-make".
# 
# Additional cmake arguments:
#   -DWITH_PYMOD=ON/OFF - Include Python module targets, default is OFF
#   -DFVS_VARIANTS=<variant list> - Explicitly list the variants to include in
#           the build as a simicolon seperated list of variant abbreviations,
#           eg. pnc;wcc;ncc;soc, the default is to include all variants.
#   -DDEBUG=ON/OFF - Include debugging info with all compiled binaries
#   -DRELEASE=ON/OFF - Compile with optimization.
#   -DPROFILE=ON/OFF - Include profiling info with all compiled binaries.
#   -DSTATIC=ON/OFF - Build common libraries statically.

cmake_minimum_required (VERSION 2.8 FATAL_ERROR)

project(OPEN_FVS C CXX Fortran)

set(version "Open-FVS")

#Assumes the FVS source is one level up from the parent CmakeLists.txt
#Used to set the prefix of all files in *sourceList.txt
get_filename_component(src_root "${CMAKE_CURRENT_LIST_DIR}/.." ABSOLUTE)
set(source_list_dir ${CMAKE_CURRENT_LIST_DIR})

if (NOT FVS_VARIANTS)
    set(FVS_VARIANTS "all" CACHE STRING "FVS variants to configure" FORCE)
endif()

if (NOT WITH_PYMOD)
    set(WITH_PYMOD OFF CACHE BOOL "Build the Python module module." FORCE)
endif()

#FIXME: There is possibly more than one destination for the resulting binaries
#      Perhaps this should be handled with installer packaging.
# set(INSTALL_DIR "${CMAKE_CURRENT_LIST_DIR}/FVSbin" CACHE PATH
        # "Install compiled binaries." FORCE)

set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)

if (CMAKE_GENERATOR MATCHES "Visual Studio 10")
    message(STATUS "Building FVS with VS10/Intel")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /DWIN32 /D_WINDOWS /W3 /Zm100" CACHE STRING "VS10 mod A" FORCE)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /DWIN32 /D_WINDOWS /W3 /Zm100" CACHE STRING "VS10 mod B" FORCE)
elseif (CMAKE_GENERATOR MATCHES "MinGW Makefiles")
    message(STATUS "Building FVS with MinGW (gcc, gfortran)")
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -static-libgfortran -static-libgcc")
    add_definitions(-DANSI -DWINDOWS -D_WINDLL -DCMPgcc)
    link_libraries(odbc32)
elseif (CMAKE_GENERATOR MATCHES "Unix Makefiles")
    message(STATUS "Building FVS with Unix (gcc, gfortran)")
    #static libraries are probably not necessary on this platform
    #set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -static-libgfortran -static-libgcc")
    add_definitions(-DANSI -DCMPgcc)
    link_libraries(odbc)
else ()
    message(FATAL_ERROR "Unknown FVS toolchain; exiting")    
endif()

if (DEBUG)
    set(CMAKE_BUILD_TYPE DEBUG)
    set (CMAKE_Fortran_FLAGS_DEBUG   "-fno-f2c -O0 -g")
endif()

if (RELEASE)
    set(CMAKE_BUILD_TYPE RELEASE)
    #set (CMAKE_Fortran_FLAGS_RELEASE "-funroll-all-loops -fno-f2c -O2")
    set (CMAKE_Fortran_FLAGS_RELEASE "-fno-f2c -O2")
endif()

if (PROFILE)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pg")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pg")
    set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -pg")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_FLAGS} -pg")
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -pg")
endif (PROFILE)

#Process the variant list command line argument and make a list of source lists
#  eg. cmake <...> -DFVS_VARIANTS=pnc;wcc;iec
string(TOLOWER ${FVS_VARIANTS} FVS_VARIANTS)
message(STATUS "VARIANTS = ${FVS_VARIANTS}")
message(STATUS "src_root = ${src_root}")
if (FVS_VARIANTS STREQUAL "all")
    file(GLOB source_lists "${source_list_dir}/FVS*_sourceList.txt")
    set(FVS_VARIANTS "")
    foreach (fn ${source_lists})
        string(REGEX REPLACE ".*FVS(.+)_sourceList.txt" "\\1" var ${fn})
        list(APPEND FVS_VARIANTS ${var})
    endforeach(fn)
else()
    set(source_lists "")
    foreach(var ${FVS_VARIANTS})
        set(fn "${source_list_dir}/FVS${var}_sourceList.txt")
        if (NOT EXISTS "${fn}")
            message(FATAL_ERROR "No source list for variant ${var}: ${fn}")
        else()
            message(STATUS "Adding source list for variant: ${var} - ${to_find} - ${fn}")
            list(APPEND source_lists ${fn})
        endif()
    endforeach(var)
endif()
    
list(SORT source_lists)
message(STATUS "source_lists = ${source_lists}")
message(STATUS "FVS_VARIANTS = ${FVS_VARIANTS}")

#Setup targest for the mkdbsTypeDefs generator, SQL, FFE Libraries
##NOTE: if these libraries are variant specific then we have a problem
#       and they should really be static libraries build in the subprojects.
list(GET source_lists 0 source_list)

file(STRINGS ${source_list} sql_src REGEX "fvsSQL.c")
string(REPLACE "../" "${src_root}/" sql_src ${sql_src})
if (STATIC)
    add_library(FVSsql STATIC ${sql_src})
else ()
    add_library(FVSsql SHARED ${sql_src})
endif()

file(STRINGS ${source_list} typedefs_src REGEX "mkdbsTypeDefs.c")
string(REPLACE "../" "${src_root}/" typedefs_src ${typedefs_src})
add_executable(mkdbsTypeDefs ${typedefs_src})

set(dbstypedefs_f77 "${CMAKE_CURRENT_BINARY_DIR}/DBSTYPEDEFS.F77")

#Execute the DBSTYPEDEFS.F77 generator.
add_custom_command(
        OUTPUT ${dbstypedefs_f77}
        COMMAND mkdbsTypeDefs
        DEPENDS mkdbsTypeDefs)

#Dummy target so the DBSTYPEDEFS.F77 generator can be used as a dependency.
add_custom_target(gen_dbstypedefs ALL DEPENDS ${dbstypedefs_f77})

#Loop through the source files to gather the header file paths
set(include_dirs)
set(ffe_source)
file(STRINGS ${source_list} file_list)
foreach (fn ${file_list})
    #repoint the path to the true source location.
    string(REPLACE "../" "${src_root}/" fn ${fn})
    get_filename_component(filename ${fn} NAME)
    get_filename_component(pathname ${fn} PATH)
    get_filename_component(extname ${fn} EXT)

    if ((${extname} STREQUAL ".h") OR (${extname} STREQUAL ".F77"))
        list(APPEND include_dirs ${pathname})
    endif()
    
    if(${extname} STREQUAL ".c" OR ${extname} STREQUAL ".cpp")
        if (NOT filename STREQUAL mkdbsTypeDefs.c AND
                NOT ${filename} STREQUAL fvsSQL.c)
            list (APPEND ffe_source ${fn})        
        endif()
    endif()

    unset(filename CACHE)
    unset(pathname CACHE)
    unset(extname CACHE)
endforeach(fn)

list(REMOVE_DUPLICATES include_dirs)
list(APPEND include_dirs ${CMAKE_CURRENT_BINARY_DIR})        
include_directories(BEFORE ${include_dirs})

#TODO: if FFE is truly variant agnostic, seperate it's source list text file.
if (STATIC)
    add_library(FVSfofem STATIC ${ffe_source})
else ()
    add_library(FVSfofem SHARED ${ffe_source})
endif ()

if (NOT STATIC)
    install(TARGETS FVSfofem FVSsql DESTINATION "${version}/bin")
endif()

#Now configure each requested variant.
list(LENGTH FVS_VARIANTS num_variants)
message(STATUS "Number of FVS Variants = ${num_variants}.")
math(EXPR num_variants "${num_variants}-1")
foreach(v RANGE ${num_variants})
    list(GET FVS_VARIANTS ${v} variant)
    get_filename_component(variant_dir ${CMAKE_BINARY_DIR}/${variant} ABSOLUTE)
    message(STATUS "Variant Dir = ${variant_dir}")

    file(MAKE_DIRECTORY ${variant_dir})

    #write out the modified source list file
    list(GET source_lists v srclst_fn)
    message(STATUS "Source List File: ${srclst_fn}")
    file(STRINGS ${srclst_fn}  source_list  NEWLINE_CONSUME)
    string(REPLACE "../" "${src_root}/" source_list ${source_list})
    file(WRITE ${variant_dir}/sourcelist.txt ${source_list})

    #write out the new variant CMakeLists file
    ##TODO: Move the variant template to a seperate file.
    file(STRINGS CMakeLists.txt cmakelist NEWLINE_CONSUME)
    string(REGEX REPLACE ".*##DO NOT REMOVE THIS TAG##" ""
           cmakelist ${cmakelist})
    #replace template strings in the 
    string(REGEX REPLACE "<<variant>>" "${variant}" cmakelist ${cmakelist})
    # string(REGEX REPLACE "<<install_dir>>" "${INSTALL_DIR}" cmakelist ${cmakelist})
    string(REGEX REPLACE "<<source_list>>" "${variant_dir}/sourcelist.txt" cmakelist ${cmakelist})
    string(REGEX REPLACE "<<with_pymod>>" ${WITH_PYMOD} cmakelist ${cmakelist})
    file(WRITE ${variant_dir}/CMakeLists.txt ${cmakelist})
    
    #Add the the FVS variant CMakeLists.txt as a sub-project
    add_subdirectory(${variant_dir} ${variant_dir})
endforeach()

return()

##This text below this tag becomes the CMakeLists.txt file in the subdirectory
##DO NOT REMOVE THIS TAG##
cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

project(FVS<<variant>> C CXX Fortran)

#Replaced by regex during configuration
set(variant <<variant>>)
set(WITH_PYMOD <<with_pymod>>)
set(source_list <<source_list>>)
# set(INSTALL_DIR <<install_dir>>)

set(fvs_exe "FVS${variant}")
set(fvs_lib "FVS_${variant}")

message(STATUS "Configure variant: ${variant}")
message(STATUS "CMake Build Type: ${CMAKE_BUILD_TYPE}")
message(STATUS "source_list = ${source_list}")
message(STATUS "fvs_exe = ${fvs_exe}")
message(STATUS "fvs_lib = ${fvs_lib}")

set(include_dirs)
set(fvs_source)
set(main_source)
set(pymod_source)

file(STRINGS ${source_list} file_list)
foreach (fn ${file_list})
    get_filename_component(filename ${fn} NAME)
    get_filename_component(pathname ${fn} PATH)
    get_filename_component(extname ${fn} EXT)
    
    if(WITH_PYMOD)
        if (${filename} STREQUAL "apisubs.f" OR
            ${filename} STREQUAL "cmdline.f" OR
            ${filename} STREQUAL "filopn.f" OR
            ${filename} STREQUAL "fvs.f")
            list(APPEND pymod_source ${fn})
        endif()
    endif()
    
    if ((${extname} STREQUAL ".h") OR (${extname} STREQUAL ".F77"))
        list(APPEND include_dirs ${pathname})
    endif()
    
    if ((${extname} STREQUAL ".f") OR (${extname} STREQUAL ".f90"))
        if (${filename} STREQUAL "main.f")
            list(APPEND main_source ${fn})
        else()
            list (APPEND fvs_source ${fn})
        endif()
    endif()

    unset(filename CACHE)
    unset(pathname CACHE)
    unset(extname CACHE)
    
endforeach(fn)

list(REMOVE_DUPLICATES include_dirs)
list(APPEND include_dirs ${CMAKE_CURRENT_BINARY_DIR})

include_directories(BEFORE ${include_dirs})

##TODO: Enable static linking option
add_library(${fvs_lib} SHARED ${fvs_source})

if (WIN32)
    set_target_properties(${fvs_lib} PROPERTIES
            LINK_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--output-def,fooBar.def"
            )
endif ()

#add the shared libraries from the top level project
target_link_libraries(${fvs_lib} FVSfofem FVSsql)

#Require the DBSTYPEDEFS.F77 file for the FVS library
add_dependencies(${fvs_lib} gen_dbstypedefs)

add_executable (${fvs_exe} ${main_source})
target_link_libraries(${fvs_exe} ${fvs_lib})

set_target_properties(${fvs_exe} PROPERTIES LINKER_LANGUAGE Fortran)

#Only add the Python module targets if it was requested
if (WITH_PYMOD)
    message(STATUS "Build the Python module.")
    ##TODO: This works well, but the safer approach would be to use distutils
    ##      with a template setup.py script and avoid all the F2PY command 
    ##      line manipulation.
    find_package(PythonInterp)
    find_package(PythonLibs)
    
    set(pymod "pyfvs${variant}")
    set(pymod_sig "pyfvs${variant}.pyf")
    
    ##TODO: Autodiscover the platform specific Python library file extension.
    if (WIN32)
        set(pymod_lib "${pymod}.pyd")
    else ()
        ##FIXME: OSX may require a .dylib extension
        set(pymod_lib "${pymod}.so")
    endif ()
    
    if (PYTHONINTERP_FOUND)
        message(STATUS "Found Python: ${PYTHON_EXECUTABLE}")
    else ()
        message(SEND_ERROR "Python could not be located. Make sure it is in the system PATH variable.")
    endif ()

    get_filename_component(python_home ${PYTHON_EXECUTABLE} PATH)
    if (WIN32)
        #F2PY is typically in the scripts Python subfolder on windows
        find_file(F2PY "f2py.py" PATHS "${python_home};$ENV{PATH}")
    else ()
        find_file(F2PY "f2py" PATHS "$ENV{PATH}")
    endif ()
    
    if (F2PY)
        message(STATUS "Found F2PY: ${F2PY}")
    else ()
        message(SEND_ERROR "The F2PY script could not be located. Make sure it's available in the system PATH.")
    endif ()
    
    ##FIXME: This is not a robust way to specify the F2PY/distutils compilers
    ##      It should be possible to interogate the CMake compilers
    if (CMAKE_GENERATOR MATCHES "Visual Studio 10")
        set(f2py_compiler "msvc")
        set(f2py_fcompiler "intelv")
    elseif (CMAKE_GENERATOR MATCHES "MinGW Makefiles")
        set(f2py_compiler "mingw32")
        set(f2py_fcompiler "gnu95")
    elseif (CMAKE_GENERATOR MATCHES "Unix Makefiles")
        set(f2py_compiler "unix")
        set(f2py_fcompiler "gnu95")
    else ()
        message(SEND_ERROR "F2PY compilers are not specified for this generator.")
    endif ()

    message(STATUS "pymod_source = ${pymod_source}")

    if (WIN32)
	set(f2py_includes "${include_dirs}")
    else ()
        #F2PY expects include dirs to be a colon seperated list
        set(f2py_includes)
        foreach (p ${include_dirs})
            set(f2py_includes "${f2py_includes}:${p}")
        endforeach ()
    endif ()

    ##TODO: Enable static linking option
    set(f2py_output)
    list(APPEND f2py_output "${LIBRARY_OUTPUT_PATH}/${pymod_lib}")
    list(APPEND f2py_output "${LIBRARY_OUTPUT_PATH}/${pymod_sig}")
    if (WIN32)
        add_custom_command(
                OUTPUT ${f2py_output}
                COMMAND ${python} ${F2PY} -h ${pymod_sig} -m ${pymod} --overwrite-signature --include-paths "${f2py_includes}" ${pymod_source}
                COMMAND ${python} ${F2PY} -c ${pymod_sig} -L${LIBRARY_OUTPUT_PATH} -l${fvs_lib} --compiler=${f2py_compiler} --fcompiler=${f2py_fcompiler} --build-dir ${CMAKE_CURRENT_BINARY_DIR}/f2py
                DEPENDS ${pymod_source} ${fvs_lib}
                WORKING_DIRECTORY ${LIBRARY_OUTPUT_PATH}
                )
    else ()
        add_custom_command(
                OUTPUT ${f2py_output}
                COMMAND ${F2PY} -h ${pymod_sig} -m ${pymod} --overwrite-signature --include-paths "${f2py_includes}" ${pymod_source}
                COMMAND ${F2PY} -c ${pymod_sig} -L${LIBRARY_OUTPUT_PATH} -l${fvs_lib} --compiler=${f2py_compiler} --fcompiler=${f2py_fcompiler} --build-dir ${CMAKE_CURRENT_BINARY_DIR}/f2py
                DEPENDS ${pymod_source} ${fvs_lib}
                WORKING_DIRECTORY ${LIBRARY_OUTPUT_PATH}
                )
    endif ()
    add_custom_target(${pymod} ALL DEPENDS ${f2py_output})
    # add_dependencies(ALL ${pymod})
    
    #ensure the f2py sub folder can be cleaned
    set_directory_properties(PROPERTIES 
            ADDITIONAL_MAKE_CLEAN_FILES "${CMAKE_CURRENT_BINARY_DIR}/f2py"
            )
    
    #TODO: setup a destination relative to Python site-packages or equivalent
    install(FILES "${LIBRARY_OUTPUT_PATH}/${pymod_lib}" DESTINATION "${version}/bin")

endif()

#add a target to build everything
if (WITH_PYMOD)
    add_custom_target(${variant} DEPENDS ${pymod} ${fvs_exe} ${fvs_lib})
else ()
    add_custom_target(${variant} DEPENDS ${fvs_exe} ${fvs_lib})
endif ()

##TODO: These may have different final destination depending on platform
install(TARGETS ${fvs_exe} DESTINATION "${version}/bin")
install(TARGETS ${fvs_lib} DESTINATION "${version}/bin")
