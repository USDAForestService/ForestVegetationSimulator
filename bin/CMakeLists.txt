# This CMakeLists file will generate a hierarchical build for Open-FVS.
#
# Note that every effort has been made to be platform independent, but surely
# some things will be overlooked. Please let us know of any bugs or quirks.
# Some support is included for Visual Studio and Intel compilers, but most 
# work supports GCC/GFortran under MinGW and Linux.
#
# Alternate configurations can be generated by calling cmake from configuration
# specific folders.  This may be useful for keeping a test/debug environment
# and release build in the same folder tree. Cmake tracks all dependent source 
# files and generated object code within the project subfolder, thus avoiding 
# cross-build polution and redundant compilation where possible.
#
# Generated binaries are placed in the FVSbin subfolder.
#
# Example: A project folder for a debug build and a seperate folder for releas
#   mkdir <FVS bin>/debug
#   cd <FVS bin>/debug
#   cmake .. -G"MinGW Makefiles" -DFVS_VARIANTS=pnc;wcc -DDEBUG=ON -DWITH_PYMOD=ON
#   mingw32-make -j4
#
#   mkdir <FVS bin>/release
#   cd <FVS bin>/release
#   cmake .. -G"MinGW Makefiles" -DFVS_VARIANTS=pnc;wcc -DRELEASE=ON -DWITH_PYMOD=ON
#   mingw32-make -j4
#
# CMake will create a subfolder for each FVS variant, copy in the cmake list 
# and source list files.  A sub-project is then specified for each variant. The
# common libraries (FVSsql,FVSffe) are built in the top evel folder where 
# they can be located by each variant sub-project.
#
# The result is a target for each executable, library, Python module. These
# targets can then be built individually or as a group with the "all" target. 
# For instance "mingw32-make FVSpnc" would generate the common libraries, the
# PNC shared library and the PNC executable.  "mingw32-make pyfvspnc" would 
# result in the common libraries, PNC shared library, and the Python module
# module, but not the PNC executable.  "mingw32-make FVS_pnc" would result in 
# common libraries and the PNC shared library, but no executable or Python
# module.  Any combination of targets can be specified in one call to
# "mingw32-make".
# 
# Additional cmake arguments:
#   -DWITH_PYMOD=ON/OFF - Include Python module targets, default is OFF
#   -DFVS_VARIANTS=<variant list> - Explicitly list the variants to include in
#           the build as a simicolon seperated list of variant abbreviations,
#           eg. pnc;wcc;ncc;soc, the default is to include all variants.
#   -DDEBUG=ON/OFF - Include debugging info with all compiled binaries
#   -DRELEASE=ON/OFF - Compile with optimization.
#   -DPROFILE=ON/OFF - Include profiling info with all compiled binaries.
#   -DSTATIC=ON/OFF - Build common libraries statically.

cmake_minimum_required (VERSION 2.8 FATAL_ERROR)

project(OPEN_FVS C CXX Fortran)

set(version "Open-FVS")

#Assumes the FVS source is one level up from the parent CmakeLists.txt
#Used to set the prefix of all files in *sourceList.txt
get_filename_component(src_root "${CMAKE_CURRENT_LIST_DIR}/.." ABSOLUTE)
set(source_list_dir ${CMAKE_CURRENT_LIST_DIR})

if (NOT FVS_VARIANTS)
    set(FVS_VARIANTS "all" CACHE STRING "FVS variants to configure" FORCE)
endif()

if (NOT WITH_PYMOD)
    set(WITH_PYMOD OFF CACHE BOOL "Build the Python module module." FORCE)
endif()

#FIXME: There is possibly more than one destination for the resulting binaries
#      Perhaps this should be handled with installer packaging.
# set(INSTALL_DIR "${CMAKE_CURRENT_LIST_DIR}/FVSbin" CACHE PATH
        # "Install compiled binaries." FORCE)

set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)

if (CMAKE_GENERATOR MATCHES "Visual Studio 10")
    message(STATUS "Building FVS with VS10/Intel")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /DWIN32 /D_WINDOWS /W3 /Zm100" CACHE STRING "VS10 mod A" FORCE)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /DWIN32 /D_WINDOWS /W3 /Zm100" CACHE STRING "VS10 mod B" FORCE)

elseif (CMAKE_GENERATOR MATCHES "MinGW Makefiles") # AND WIN32
    message(STATUS "Building FVS with MinGW (gcc, gfortran)")
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -static-libgfortran -static-libgcc -static-libstdc++")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -static -static-libgfortran -static-libgcc -static-libstdc++")
    add_definitions(-DANSI -DWINDOWS -D_WINDLL -DCMPgcc)
    
elseif (CMAKE_GENERATOR MATCHES "Unix Makefiles")
    message(STATUS "Building FVS with Unix (gcc, gfortran)")
    #static libraries are probably not necessary on this platform
    #set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -static-libgfortran -static-libgcc")
    add_definitions(-DANSI -DCMPgcc)

else ()
    message(FATAL_ERROR "Unknown FVS toolchain; exiting")    

endif()

if (DEBUG)
    set(CMAKE_BUILD_TYPE DEBUG)
    set (CMAKE_Fortran_FLAGS_DEBUG   "-Og -g")
endif()

if (RELEASE)
    set(CMAKE_BUILD_TYPE RELEASE)
    set (CMAKE_Fortran_FLAGS_RELEASE "-O2 -ffast-math")
endif()

if (PROFILE)
    set(CMAKE_CXX_FLAGS "-pg -fprofile-arcs -ftest-coverage ${CMAKE_CXX_FLAGS}")
    set(CMAKE_C_FLAGS "-pg -fprofile-arcs -ftest-coverage ${CMAKE_C_FLAGS}")
    set(CMAKE_Fortran_FLAGS "-pg -fprofile-arcs -ftest-coverage ${CMAKE_Fortran_FLAGS}")
    set(CMAKE_EXE_LINKER_FLAGS "-pg -fprofile-arcs -ftest-coverage ${CMAKE_EXE_FLAGS}")
    set(CMAKE_SHARED_LINKER_FLAGS "-pg -fprofile-arcs -ftest-coverage ${CMAKE_SHARED_LINKER_FLAGS}")
endif (PROFILE)

# TODO: Add architecture flags, -m32; -march=..., etc.
##-----END COMPILER FLAGS-----##

#FIXME: There is possibly more than one destination for the resulting binaries
#      Perhaps this should be handled with installer packaging.
set(CMAKE_INSTALL_PREFIX "${CMAKE_CURRENT_LIST_DIR}/FVSbin")
set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)

#Process the variant list command line argument and make a list of source lists
#  eg. cmake <...> -DFVS_VARIANTS=pnc;wcc;iec
string(TOLOWER ${FVS_VARIANTS} FVS_VARIANTS)
message(STATUS "VARIANTS = ${FVS_VARIANTS}")
message(STATUS "src_root = ${src_root}")
if (FVS_VARIANTS STREQUAL "all")
    file(GLOB source_lists "${source_list_dir}/FVS*_sourceList.txt")
    set(FVS_VARIANTS "")
    foreach (fn ${source_lists})
        string(REGEX REPLACE ".*FVS(.+)_sourceList.txt" "\\1" var ${fn})
        list(APPEND FVS_VARIANTS ${var})
    endforeach(fn)
else()
    set(source_lists "")
    foreach(var ${FVS_VARIANTS})
        set(fn "${source_list_dir}/FVS${var}_sourceList.txt")
        if (NOT EXISTS "${fn}")
            message(FATAL_ERROR "No source list for variant ${var}: ${fn}")
        else()
            message(STATUS "Adding source list for variant: ${var} - ${fn}")
            list(APPEND source_lists ${fn})
        endif()
    endforeach(var)
endif()
    
message(STATUS "source_lists = ${source_lists}")
message(STATUS "FVS_VARIANTS = ${FVS_VARIANTS}")

# Setup targets for the mkdbsTypeDefs generator, SQL, FFE Libraries
##NOTE: if these libraries are variant specific then we have a problem
#       and they should really be static libraries build in the subprojects.
list(GET source_lists 0 source_list)

# Extract the SQL source code files
file(STRINGS ${source_list} sql_source REGEX "fvsSQL.c")
string(REPLACE "../" "${src_root}/" sql_source ${sql_source})

# Add the command to generate the SQL type defs
file(STRINGS ${source_list} typedefs_src REGEX "mkdbsTypeDefs.c")
string(REPLACE "../" "${src_root}/" typedefs_src ${typedefs_src})
add_executable(mkdbsTypeDefs ${typedefs_src})

set(dbstypedefs_f77 "${CMAKE_CURRENT_BINARY_DIR}/DBSTYPEDEFS.F77")

#Execute the DBSTYPEDEFS.F77 generator.
add_custom_command(
        OUTPUT ${dbstypedefs_f77}
        COMMAND mkdbsTypeDefs
        DEPENDS mkdbsTypeDefs)

#Dummy target so the DBSTYPEDEFS.F77 generator can be used as a dependency.
add_custom_target(gen_dbstypedefs ALL DEPENDS ${dbstypedefs_f77})

#Loop through the source files to gather the header file paths
set(include_dirs)
set(ffe_source)
file(STRINGS ${source_list} file_list)
foreach (fn ${file_list})
    #repoint the path to the true source location.
    string(REPLACE "../" "${src_root}/" fn ${fn})
    get_filename_component(filename ${fn} NAME)
    get_filename_component(pathname ${fn} PATH)
    get_filename_component(extname ${fn} EXT)

    if ((${extname} STREQUAL ".h") OR (${extname} STREQUAL ".F77"))
        list(APPEND include_dirs ${pathname})
    endif()
    
    if(${extname} STREQUAL ".c" OR ${extname} STREQUAL ".cpp")
        if (NOT filename STREQUAL mkdbsTypeDefs.c AND
                NOT ${filename} STREQUAL fvsSQL.c)
            list (APPEND ffe_source ${fn})        
        endif()
    endif()

    unset(filename CACHE)
    unset(pathname CACHE)
    unset(extname CACHE)
endforeach(fn)

list(REMOVE_DUPLICATES include_dirs)
list(APPEND include_dirs ${CMAKE_CURRENT_BINARY_DIR})        
include_directories(BEFORE ${include_dirs})

# Compile the FFE and SQL code into object libraries for use down stream
add_library(sql_objs OBJECT ${sql_source})
add_library(ffe_objs OBJECT ${ffe_source})

#TODO: if FFE is truly variant agnostic, seperate it's source list text file.
if (NOT STATIC_LINK)
    # If linking shared libraries, create them now
    add_library(FVSsql SHARED $<TARGET_OBJECTS:sql_objs>)
    
    if (WIN32)
        target_link_libraries(FVSsql odbc32)
    else ()
        target_link_libraries(FVSsql odbc)
    endif ()
    
    add_library(FVSffe SHARED $<TARGET_OBJECTS:ffe_objs>)
    install(TARGETS FVSffe FVSsql DESTINATION "${version}/bin")
endif()

# Configure each requested variant.
list(LENGTH FVS_VARIANTS num_variants)
message(STATUS "Number of FVS Variants = ${num_variants}.")
math(EXPR num_variants "${num_variants}-1")
foreach(v RANGE ${num_variants})
    list(GET FVS_VARIANTS ${v} variant)
    get_filename_component(variant_dir ${CMAKE_BINARY_DIR}/${variant} ABSOLUTE)
    message(STATUS "Variant Dir = ${variant_dir}")

    file(MAKE_DIRECTORY ${variant_dir})

    # Write out the modified source list file
    list(GET source_lists ${v} srclst_fn)
    message(STATUS "Source List File: ${srclst_fn}")
    file(STRINGS ${srclst_fn}  source_list  NEWLINE_CONSUME)
    string(REPLACE "../" "${src_root}/" source_list ${source_list})
    file(WRITE ${variant_dir}/sourcelist.txt ${source_list})

    # Write out the new variant CMakeLists file
    # TODO: Move the variant template to a seperate file.
    file(STRINGS CMakeLists.txt cmakelist NEWLINE_CONSUME)
    string(REGEX REPLACE ".*##-----DO NOT REMOVE THIS TAG-----##" ""
           cmakelist ${cmakelist})
    
    # Replace template strings 
    string(REGEX REPLACE "<<variant>>" "${variant}" cmakelist ${cmakelist})
    # string(REGEX REPLACE "<<install_dir>>" "${INSTALL_DIR}" cmakelist ${cmakelist})
    string(REGEX REPLACE "<<source_list>>" "${variant_dir}/sourcelist.txt" cmakelist ${cmakelist})
    string(REGEX REPLACE "<<with_pymod>>" ${WITH_PYMOD} cmakelist ${cmakelist})
    file(WRITE ${variant_dir}/CMakeLists.txt ${cmakelist})
    
    # Add the the FVS variant CMakeLists.txt as a sub-project
    add_subdirectory(${variant_dir} ${variant_dir})
endforeach()

return()

##This text below this tag becomes the CMakeLists.txt file in the subdirectory
##-----DO NOT REMOVE THIS TAG-----##
cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

project(FVS<<variant>> C CXX Fortran)
set(fvs_exe "FVS${variant}")
set(fvs_lib "FVS_${variant}")

#Replaced by regex during configuration
set(variant <<variant>>)
set(WITH_PYMOD <<with_pymod>>)
set(source_list <<source_list>>)
# set(INSTALL_DIR <<install_dir>>)

set(fvs_exe "FVS${variant}")
set(fvs_lib "FVS_${variant}")

message(STATUS "Configure variant: ${variant}")
message(STATUS "CMake Build Type: ${CMAKE_BUILD_TYPE}")
message(STATUS "source_list = ${source_list}")
message(STATUS "fvs_exe = ${fvs_exe}")
message(STATUS "fvs_lib = ${fvs_lib}")

set(include_dirs)
set(fvs_source)
set(main_source)
set(pymod_source)

file(STRINGS ${source_list} file_list)
foreach (fn ${file_list})
    if (NOT ${fn} MATCHES "#.*")
        get_filename_component(filename ${fn} NAME)
        get_filename_component(pathname ${fn} PATH)
        get_filename_component(extname ${fn} EXT)
        
        if(WITH_PYMOD)
            if (${filename} STREQUAL "apisubs.f" OR
                ${filename} STREQUAL "cmdline.f" OR
                ${filename} STREQUAL "filopn.f" OR
                ${filename} STREQUAL "fvs.f")
                list(APPEND pymod_source ${fn})
            endif()
        endif()
        
        if ((${extname} STREQUAL ".h") OR (${extname} STREQUAL ".F77"))
            list(APPEND include_dirs ${pathname})
        endif()
        
        if ((${extname} STREQUAL ".f") OR (${extname} STREQUAL ".f90"))
            if (${filename} STREQUAL "main.f")
                list(APPEND main_source ${fn})
            else()
                list (APPEND fvs_source ${fn})
            endif()
        endif()
    
        unset(filename CACHE)
        unset(pathname CACHE)
        unset(extname CACHE)
    endif()
endforeach(fn)

list(REMOVE_DUPLICATES include_dirs)
list(APPEND include_dirs ${CMAKE_CURRENT_BINARY_DIR})

include_directories(BEFORE ${include_dirs})

#---Compile the variant FVS code to an object library
set(fvs_objs "fvs${variant}_objs")
add_library(${fvs_objs} OBJECT ${fvs_source})

##TODO: Need a fixup for VBA 
#if (WIN32)
#    set_target_properties(${fvs_lib} PROPERTIES
#            LINK_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--output-def,fooBar.def"
#            )
#endif ()

#Require the DBSTYPEDEFS.F77 file for the SQL library
add_dependencies(${fvs_objs} gen_dbstypedefs)

#--- Link the shared library and executables
if (STATIC_LINK)
    add_library(${fvs_lib} SHARED
        $<TARGET_OBJECTS:${fvs_objs}>
        $<TARGET_OBJECTS:ffe_objs>
        $<TARGET_OBJECTS:sql_objs>
        )
    add_executable (${fvs_exe} ${main_source} $<TARGET_OBJECTS:${fvs_objs}> $<TARGET_OBJECTS:ffe_objs> $<TARGET_OBJECTS:sql_objs>)

    if (WIN32)
        target_link_libraries(${fvs_lib} odbc32)
        target_link_libraries(${fvs_exe} odbc32)
    else ()
        target_link_libraries(${fvs_lib} odbc)
        target_link_libraries(${fvs_exe} odbc)
    endif ()

else()
    add_library(${fvs_lib} SHARED $<TARGET_OBJECTS:${fvs_objs}>)
    target_link_libraries(${fvs_lib} FVSffe FVSsql)
    
    add_executable (${fvs_exe} ${main_source} $<TARGET_OBJECTS:${fvs_objs}>)
    target_link_libraries(${fvs_exe} FVSffe FVSsql)

endif()

set_target_properties(${fvs_exe} PROPERTIES LINKER_LANGUAGE Fortran)

install(TARGETS ${fvs_lib} DESTINATION "${version}/bin")
install(TARGETS ${fvs_exe} DESTINATION "${version}/bin")

# Build the Python module if requested
if (WITH_PYMOD)
    message(STATUS "Build the Python module.")
    ##TODO: This works well, but the safer approach would be to use distutils
    ##      with a template setup.py script and avoid all the F2PY command 
    ##      line manipulation.
    ##      NOTE: distutils worked up to linking with the FVS object library
    ##            I could not find a way to get the list of obj files.
    find_package(PythonInterp 2.7 REQUIRED)
    find_package(PythonLibs REQUIRED)
#    find_package(Numpy REQUIRED)

    set(pymod "pyfvs${variant}")
    set(pymod_sig "pyfvs${variant}.pyf")
    
    # Discover key Python configuration variables
    execute_process(
            COMMAND ${PYTHON_EXECUTABLE} -c "import sysconfig\nprint sysconfig.get_config_var('py_version_nodot')"
            OUTPUT_VARIABLE python_ver
            OUTPUT_STRIP_TRAILING_WHITESPACE
            )
    execute_process(
            COMMAND ${PYTHON_EXECUTABLE} -c "import sysconfig\nprint sysconfig.get_config_var('SO')"
            OUTPUT_VARIABLE pymod_ext
            OUTPUT_STRIP_TRAILING_WHITESPACE
            )
     execute_process(
            COMMAND ${PYTHON_EXECUTABLE} -c "import numpy as n\nprint n.get_include()"
            OUTPUT_VARIABLE numpy_include
            OUTPUT_STRIP_TRAILING_WHITESPACE
            )
    
    include_directories(
        ${PYTHON_INCLUDE_DIRS}
        ${numpy_include}
        )
    
    set(CMAKE_LIBRARY_PATH ${CMAKE_LIBRARY_PATH} ${PYTHON_LIBRARIES})
    
    ##FIXME: This is not a robust way to specify the F2PY/distutils compilers
    ##      It should be possible to interogate the CMake compilers
    if (CMAKE_GENERATOR MATCHES "Visual Studio 10")
        set(f2py_compiler "msvc")
        set(f2py_fcompiler "intelv")
    elseif (CMAKE_GENERATOR MATCHES "MinGW Makefiles")
        set(f2py_compiler "mingw32")
        set(f2py_fcompiler "gnu95")
    elseif (CMAKE_GENERATOR MATCHES "Unix Makefiles")
        set(f2py_compiler "unix")
        set(f2py_fcompiler "gnu95")
    else ()
        message(SEND_ERROR "F2PY compilers are not specified for this generator.")
    endif ()

    message(STATUS "pymod_source = ${pymod_source}")

    # Define the F2PY outputs to expect
    file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/f2py")
    set(f2py_sig "${CMAKE_CURRENT_BINARY_DIR}/f2py/${pymod_sig}")
    set(f2py_lib "${LIBRARY_OUTPUT_PATH}/${pymod}${pymod_ext}")
    
    set(f2py_gen "${CMAKE_CURRENT_BINARY_DIR}/f2py_gen.py")
    set(f2py_wrappers "${CMAKE_CURRENT_BINARY_DIR}/f2py/${pymod}module.c")
    list(APPEND f2py_wrappers "${CMAKE_CURRENT_BINARY_DIR}/f2py/${pymod}-f2pywrappers.f")
    list(APPEND f2py_wrappers "${CMAKE_CURRENT_BINARY_DIR}/f2py/${pymod}-f2pywrappers2.f90")
    list(APPEND f2py_wrappers "${CMAKE_CURRENT_BINARY_DIR}/f2py/fortranobject.c")
    
    # Update the F2PY script template with the current configuration and save it to the build dir
    configure_file("${CMAKE_CURRENT_LIST_DIR}/../../f2py_gen.py" ${f2py_gen})
    #message(STATUS "F2PY Script: " ${f2py_gen})
    
    # Execute the configured F2PY script to geneate the wrapper module code 
    add_custom_command(
            OUTPUT ${f2py_sig} ${f2py_wrappers}
            COMMAND ${PYTHON_EXECUTABLE} ${f2py_gen}
            DEPENDS ${pymod_source}
            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
            )
    
    #message(STATUS "F2PY Wrappers: " ${f2py_wrappers})
    
    if (STATIC_LINK)
        add_library(${pymod}-lib SHARED ${f2py_wrappers}
            $<TARGET_OBJECTS:sql_objs>
            $<TARGET_OBJECTS:ffe_objs>
            $<TARGET_OBJECTS:${fvs_objs}>
            )
        target_link_libraries(${pymod}-lib ${PYTHON_LIBRARIES}) # "python${python_ver}")

        if (WIN32)
            target_link_libraries(${pymod}-lib odbc32)
        else ()
            target_link_libraries(${pymod}-lib odbc)
        endif ()
        
    else ()
        # Link the Python module library to the FVS variant shared library
        add_library(${pymod}-lib SHARED ${f2py_wrappers})
        target_link_libraries(${pymod}-lib ${fvs_lib} ${PYTHON_LIBRARIES})
        
    endif ()
    
    # Python is a C language, so link accordingly
    set_target_properties(${pymod}-lib PROPERTIES
            LINKER_LANGUAGE CXX
            OUTPUT_NAME ${pymod}
            SUFFIX ${pymod_ext}
            PREFIX ""
            )
    
    add_dependencies(${pymod}-lib ${f2py_sig})    
    add_custom_target(${pymod} ALL DEPENDS ${pymod}-lib)
    
    #ensure the build folder can be cleaned
    set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${CMAKE_CURRENT_BINARY_DIR}/f2py")

    #TODO: setup a destination relative to Python site-packages or equivalent
    install(FILES "${LIBRARY_OUTPUT_PATH}/${pymod}${pymod_ext}" DESTINATION "${version}/bin")
#    install(CODE 'execute_process(COMMAND ${python} ${f2py_setup} install --prefix "${version}/bin")')
    
    message(STATUS "*** End PyMod Configuration ***")
    
endif()

# Add a variant name target to build everything
if (WITH_PYMOD)
    add_custom_target(${variant} DEPENDS ${pymod}-lib ${fvs_exe} ${fvs_lib})
else ()
    add_custom_target(${variant} DEPENDS ${fvs_exe} ${fvs_lib})
endif ()
